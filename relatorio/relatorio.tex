\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}
\usepackage{indentfirst}
\usepackage{graphicx}

\title{Projeto de Laboratórios de Informática 3\\Grupo 21}
\author{Diogo Braga A82547 \and João Silva A82005 \and Ricardo Caçador A81064}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
  Este documento apresenta o projeto de Laboratórios de Informática
  3 (LI3), do curso de Engenharia Informática da Universidade
  do Minho.

  O projeto baseia-se na criação de um sistema de análise de ficheiros 
  XML que possuem informações do Stack Overflow, um website de perguntas
  e respostas sobre programação de computadores.

\end{abstract}

\tableofcontents
\listoffigures

\section{Introdução}
\label{sec:intro}

////////////////////// POR FAZER //////////////////////

Este documento apresenta uma possível estrutura para o relatório da 2ª
fase do projeto da disciplina de Laboratórios de Informática 1 (LI1),
da Licenciatura em Engenharia Informática da Universidade do Minho,
que toma a forma de um projeto de média dimensão a ser desenvolvido na
linguagem de programação funcional Haskell.

Nesse contexto, este relatório deve relatar o trabalho desenvolvido
pelos alunos para atingir o resultado final nesse projeto, devendo
acompanhar a submissão da solução implementada. Além de servir de
treino das capacidades de comunicação escrita dos estudantes, servirá
também como elemento de avaliação para a utilização de \LaTeX{} pelos
alunos. Sendo assim o código fonte \LaTeX{} do relatório deve ser
mantido no repositório \texttt{svn} atribuído ao grupo. Um relatório desta
natureza tem geralmente uma dimensão entre 4 e 8 páginas, para além de
eventuais anexos.

A \emph{introdução} de um relatório apresenta de modo geral o trabalho
descrito no relatório: o problema que se pretende resolver, a sua
contextualização e a abordagem proposta pelos alunos para o
resolver. Deve passar ao leitor não só uma perspetiva geral do
trabalho desenvolvido mas também a motivação por trás dele.

Esta secção termina normalmente com uma apresentação da estrutura do
relatório, sendo aqui apresentada uma sugestão. Neste caso, a Secção
~\ref{sec:estruturas} apresenta as estruturas de dados utilizadas 
no projeto, a Secção~\ref{sec:estrategias} indica as estratégias usadas 
para resolver as  questões apresentadas. O relatório termina com conclusões na
Secção~\ref{sec:conclusao}, onde é também apresentada uma análise
crítica dos resultados obtidos.Secção~\ref{sec:modularizacao}.

\section{Estruturas de Dados}
\label{sec:estruturas}

////////////////////// POR FAZER //////////////////////

////////////////////// TCD e TAD (ver aviso BB) //////////////////////

Esta secção tem as \emph{estruturas} do projeto.

\subsection{Estrutura TCD}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.50]{image_tcd}
\caption{Estrutura TCD} 
\label{img:tcd}
\end{figure}

\subsection{Estrutura Utilizador}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.50]{image_utilizador}
\caption{Estrutura Utilizador} 
\label{img:utilizador}
\end{figure}

\subsection{Estrutura Posts}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.50]{image_posts}
\caption{Estrutura Posts} 
\label{img:posts}
\end{figure}

\section{Modularização}
\label{sec:modularizacao}

////////////////////// POR FAZER //////////////////////

\section{Estratégias das Interrogações}
\label{sec:estrategias}

\subsection{Init}

Função que cria a \textbf{TAD\_community}. Por consequência, inicializa
as estruturas relacionadas à struct \textbf{TCD\_community}, alocando
memória e usando a função da \textit{glib}, \textbf{g\_hash\_table\_new}.

\subsection{Load}

\subsection{Query 1}

Dado o identificador de um post, a função retorna o título do post 
e o nome de utilizador do autor. Se o post for uma resposta, a função
retorna o título e o id do utilizador da pergunta correspondente.

Nesta questão, sendo o valor do \textbf{id} igual ao da \textbf{key} 
da tabela de hash, recorremos à função da \textit{glib},
\textbf{g\_hash\_table\_lookup} que dado uma \textbf{key},
retorna o \textbf{value} associado. Caso nada seja encontrado,
é retornado NULL.

Tendo agora todos os valores referentes ao \textbf{post}, caso este
seja uma pergunta, é atríbuido à primeira coordenada o \textbf{title}
do post e à segunda o \textbf{nome} de quem realizou a questão.
Encontramos o \textbf{nome} do autor da questão invocando o parâmetro
\textbf{owner\_user\_id} na mesma função \textbf{lookup} utilizada 
anteriormente, passando agora a ser esse o \textbf{key/id} associado.

Caso seja uma resposta, o primeiro parâmetro é calculado usando a mesma 
função \textbf{g\_hash\_table\_lookup}, mas agora com o 
parâmetro \textbf{parent\_id}, que numa resposta retorna o \textbf{id} 
da pergunta ao qual esta respondeu. O segundo parâmetro é igualmente
calculado como se fosse uma pergunta, mudando apenas o novo 
\textbf{value} associado.

\subsection{Query 2}

Pretendemos obter o top N utilizadores com maior número de posts de 
sempre. Para isto, são considerados tanto perguntas quanto respostas 
dadas pelo respectivo utilizador.

Nesta questão, utilizamos uma \textit{\textbf{GList*}} para armazenar 
os \textbf{values} de cada \textbf{utilizador}, sendo isto realizado
pela função da \textit{glib}, \textbf{g\_hash\_table\_get\_values}.

Depois esta lista é ordenada por número de posts (de cada utilizador)
em ordem decrescente através da função da \textit{glib}, 
\textbf{g\_list\_sort}, que usa uma função de comparação 
\textbf{compara\_posts\_u}, que tem em conta o parâmetro
\textbf{posts\_u} da estrutura.

De seguida, fazemos a filtração para o \textbf{set\_list} do 
\textbf{id} de cada utilizador.

\subsection{Query 3}

Dado um intervalo de tempo arbitrário, obtemos o número total de posts 
(identificando perguntas e respostas separadamente) neste período.

Nesta questão, utilizamos uma \textit{\textbf{GList*}} para armazenar 
os \textbf{posts} ordenados por data que se encontram na estrutura 
\textbf{date\_posts}, para de seguida percorrer estes mesmos posts.

Enquanto isso, verificamos se a \textbf{data} do post se encontra entre 
os limites referenciados pela query, através da função \textbf{difDatas},
e caso seja uma pergunta, é incrementada a primeira coordenada do par,
caso contrário é uma resposta, e é incrementada a segunda coordenada.

\subsection{Query 4}

Dado um intervalo de tempo arbitrário, retornamos todas as perguntas 
contendo uma determinada tag. O retorno da função é uma lista com os IDs das perguntas ordenadas em cronologia inversa.

Nesta questão, utilizamos uma \textit{\textbf{GList*}} para armazenar 
os \textbf{posts} ordenados por data que se encontram na estrutura 
\textbf{date\_posts}.

Enquanto isso, verificamos se a \textbf{data} do post se encontra entre 
os limites referenciados pela query, através da função \textbf{difDatas},
e se é uma pergunta. Nos posts em que os dois parâmetros são cumpridos,
colocamos as tags desses mesmos posts uma nova \textit{GList*}
usando a função \textbf{get\_tags}. Verificamos se a \textbf{tag} passada 
como parâmetro pertence à lista anterior usando a função \textbf{strcmp},
e caso pertença é inserida no início duma \textit{GList*} \textbf{res} 
que vai conter os resultados finais, através da função 
\textbf{g\_list\_insert}.

De seguida, ordenamos a lista \textbf{res} por data através da função
\textbf{g\_list\_sort}, de modo a depois poder retornar os \textbf{id's}
em questão.

\subsection{Query 5}

Dado um ID de utilizador, devolvemos a informação do seu perfil (short 
bio) e os IDs dos seus 10 últimos posts (perguntas ou respostas), 
ordenados por cronologia inversa.

Nesta questão, recorremos à função da \textit{glib}, 
\textbf{g\_hash\_table\_lookup}, para termos o \textbf{value} 
associado ao \textbf{id} do utilizador. Desta forma, retornamos a 
\textbf{bio} do utilizador.

Retornamos os últimos 10 posts acedendo à estrutura que tem os posts
ordenados por data e, começando no último elemento da \textit{
\textbf{GList*}}, vamos percorrendo a lista para trás. Caso o 
\textbf{owner\_user\_id} seja o requerido adicionamos o \textbf{id} 
do post à lista a retornar.

\subsection{Query 6}

Dado um intervalo de tempo arbitrário, devolver os IDs das N respostas 
com mais votos, em ordem decrescente do número de votos.

Nesta questão, recorremos à estrutura \textbf{date\_posts} que possuí 
as datas ordenadas. Caso o \textbf{post} seja uma pergunta e
se encontre entre as datas requeridas na query, é inserida numa nova
\textit{\textbf{GList*}} \textbf{glvotes} criada para armazenar os 
valores necessários para a resposta final.

Depois esta lista é ordenada por votos em ordem decrescente através da 
função da \textit{glib}, \textbf{g\_list\_sort}, que usa uma função de 
comparação \textbf{compara\_score}, que tem em conta o \textbf{score}
da estrutura. Finalmente acedemos ao \textbf{id\_post} relacionado, 
através dos dados respetivos da lista \textbf{glvotes}.

\subsection{Query 7}

Dado um intervalo de tempo arbitrário, devolver os IDs das N perguntas 
com mais respostas, em ordem decrescente do número de votos.

Nesta questão, recorremos à estrutura \textbf{date\_posts} que possuí 
as datas ordenadas. Caso o \textbf{post} seja uma pergunta e
se encontre entre as datas requeridas na query, é inserida numa nova
\textit{\textbf{GList*}} \textbf{glanswers} criada para armazenar os 
valores necessários para a resposta final.

Depois esta lista é ordenada por número de respostas em ordem decrescente 
através da função da \textit{glib}, \textbf{g\_list\_sort}, que usa uma 
função de comparação \textbf{compara\_answers}, que tem em conta o 
\textbf{answer\_count} da estrutura. Finalmente acedemos ao 
\textbf{id\_post} relacionado, através dos dados respetivos da lista 
\textbf{glanswers}.

\subsection{Query 8}

Dado uma palavra, devolver uma lista com os IDs de N perguntas
cujos títulos a contenham, ordenados por cronologia inversa.

Nesta questão, recorremos à estrutura \textbf{date\_posts} que possuí 
as datas ordenadas. A lista dos posts é iterada do fim para o início
de modo a ir em conta da cronologia inversa. Caso o \textbf{post} seja 
uma pergunta, e, usando a função \textbf{strstr}, caso a \textbf{word}
passada como parâmetro esteja presente no \textbf{title}, acrescentamos
o \textbf{id\_post} à lista a retornar no final.

\subsection{Query 9}

\subsection{Query 10}

Dado o ID de uma pergunta, obter a melhor resposta, tendo em conta
uma média ponderada.

Nesta questão, utilizamos uma \textit{\textbf{GList*}} para armazenar 
os \textbf{values} de cada \textbf{utilizador}, sendo isto realizado
pela função da \textit{glib}, \textbf{g\_hash\_table\_get\_values}.

Depois, identificamos a pergunta ao qual o \textbf{post} está a responder,
através do \textbf{parent\_id}. Caso essa pergunta seja o \textbf{id}
passado como parâmetro, calculamos a média ponderada tendo em conta o
\textbf{score}, o \textbf{comment\_count} e a \textbf{reputação}. Este
último parâmetro é acedido na estrutura do utilizador através da função
\textbf{g\_hash\_table\_lookup}. Quando encontramos uma média melhor é
alterado o \textbf{id\_post} a retornar no final.


\subsection{Query 11}

\subsection{Clean}

\section{Conclusões}
\label{sec:conclusao}

////////////////////// POR FAZER //////////////////////

A secção de \emph{conclusões} resume o restante documento, devendo
também apresentar uma análise crítica dos resultados atingidos tendo
em conta os objetivos definidos.

\end{document}