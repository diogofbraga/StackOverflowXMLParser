\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[portuges]{babel}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{float}

\title{Projeto de Laboratórios de Informática 3\\Grupo 21}
\author{Diogo Braga A82547 \and João Silva A82005 \and Ricardo Caçador A81064}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este documento apresenta o projeto de Laboratórios de Informática
3 (LI3), do curso de Engenharia Informática da Universidade
do Minho.

O projeto baseia-se na criação de um sistema de análise de ficheiros 
XML que possuem informações do Stack Overflow, um website de perguntas
e respostas sobre programação de computadores.

Agora realizado em Java, este projeto tem por base um anterior realizado em
C, de modo que o relatório possui muitas comparações de resoluções e
questões de eficiência entre as duas linguagens.

\end{abstract}

\tableofcontents
\listoffigures

\section{Introdução}
\label{sec:intro}

Este trabalho tem por base o parse de elementos de ficheiros XML
relacionados com a informação do website Stack Overflow, de forma
a seguidamente responder a uma série de questões relacionadas com
posts, utilizadores e tags do mesmo website. Aliado a tal está o desafio
de procurar sempre o melhor algoritmo de resolução das queries, de 
forma a tornar o código mais eficiente e o mais rápido possível.
Em todas as secções do relatório existe uma área dedicada à comparação
das duas formas de resolução, em C e Java respetivamente.

A Secção ~\ref{sec:estruturas} apresenta as estruturas de dados utilizadas 
no projeto, a Secção~\ref{sec:modularidade} aborda a modularidade, 
a Secção ~\ref{sec:encapsulamento} aborda o encapsulamento, a 
Secção ~\ref{sec:abstracao_de_dados} aborda a abstração de dados e a 
Secção~\ref{sec:estrategias} indica as estratégias usadas para resolver 
as questões apresentadas. O relatório termina com conclusões na
Secção~\ref{sec:conclusao}, onde é também apresentada uma análise
crítica dos resultados obtidos.

\section{Estruturas de Dados}
\label{sec:estruturas}

Este trabalho tem por base uma classe principal denominada 
\textbf{TCD\_community}.

Esta estrutura possui:
\begin{itemize}
	\item Classe \textbf{Utilizador} que contem um \textbf{Map} em que
    as Keys são os \textbf{Id}'s dos Utilizadores e os Values são as
    instâncias da classe \textbf{Utilizador}:
		\begin{itemize}
          \item Map \textless Long,Utilizador\textgreater \textbf{utilizador}
        \end{itemize}
	\item Classe \textbf{Posts} que contem um \textbf{Map} em que
    as Keys são os \textbf{Id}'s dos Posts e os Values são as
    instâncias da classe \textbf{Posts}:
    	\begin{itemize}
          \item Map \textless Long,Posts\textgreater \textbf{posts}
        \end{itemize}
	\item Classe \textbf{Tag} que contem um \textbf{Map} em que
    as Keys são os \textbf{Name}'s das Tags e os Values são as
    instâncias da classe \textbf{Tag}:
    	\begin{itemize}
          \item Map \textless String,Tag\textgreater \textbf{tag}
        \end{itemize}
\end{itemize}

\subsection{Comparação com C}

No projeto anterior tivemos a necessidade de ter uma estrutura com os 
posts ordenados por data. Em Java fazemos uso da interface 
\textbf{Comparator} implementada na classe requerida, e em run-time, 
usando as propriedades dos \textbf{TreeSet}'s, organizamos os posts 
úteis para a resolução da querie.


\section{Modularidade}
\label{sec:modularidade}

//////////////////// FALTA FAZER ////////////////////

Modularidade, por definição, é a divisão do código fonte em unidades 
separadas coerentes. É algo que temos em conta no nosso projeto,
existindo, por base, o ficheiro \textbf{main.c}, e depois todos os
ficheiros individuais relacionados com as \textbf{estruturas de dados}
usadas e as \textbf{queries} propostas. Estes possuem os ficheiros 
\textbf{.c} que contêm o código fonte e os \textbf{.h/header files} que
definem o que é invocável do exterior.

Modularidade torna-se portanto fundamental para lidar com a complexidade
do código, de tal forma que o código dos programas deve ser dividido por
unidades modulares pequenas e autônomas, devendo-se ter em especial atenção
a criação dos módulos que representam \textbf{abstração de dados}.

\section{Encapsulamento}
\label{sec:encapsulamento}

//////////////////// FALTA FAZER ////////////////////

Encapsulamento baseia-se na garantia de \textbf{protecção} e 
\textbf{acessos controlados aos dados}. É mais um aspeto que temos em 
conta no nosso projeto de forma a que exista uma divisão entre as operações 
que são públicas e aquelas que são internas ao módulo. Estas são privadas e,
portanto, são apenas acessíveis do exterior atráves das funções
disponibilizadas na \textbf{API}

Desta forma um tipo de dados permite ter várias instanciações,
visto que os módulos das estruturas e das queries se tornam mais genéricos.

De referir que o encapsulamento não é total, isto é, só são feitos clones
no caso das strings, atráves da função \textbf{mystrdup}. 
Ao invês disso utilizamos uma abordagem \textit{shallow}, por uma questão de 
eficiência tendo sempre o cuidado de não alterar valores das estruturas.

\section{Abstração de Dados}
\label{sec:abstracao_de_dados}

//////////////////// FALTA FAZER ////////////////////

A declaração abstrata duma estrutura esconde dos utilizadores do módulo a
implementação concreta, não tendo desta forma acesso à implementação
da mesma. Por isso mesmo, previamente, temos a declaração abstrata da 
estrutura \textbf{utilizador}, denominada de \textbf{UTILIZADOR}, no
\textit{header file}.

\section{Estratégias das Queries}
\label{sec:estrategias}

\subsection{Init}


Função que cria a \textbf{TCD\_community}. 

\subsection{Load}

Função que realiza o parse de todos os ficheiros necessários à realização
do trabalho. Após receber um \textbf{dump\_path} para os ficheiros XML,
caso não existam falhas na estrutura XML são realizadas três funções:
o \textbf{getReferenceUser}, o \textbf{getReferencePosts} e o
\textbf{getReferenceTags}.

A primeira realiza todo o parse relacionado com os \textbf{utilizadores}, 
como por exemplo o \textbf{id} ou a \textbf{reputação}. De seguida são 
colocados na estrutura todos estes elementos através da função
\textbf{set\_utilizador}.

A segunda realiza todo o parse relacionado com os \textbf{posts}, 
como por exemplo o \textbf{id\_post} ou o \textbf{post\_type\_id}. 
De seguida são colocados na estrutura todos estes elementos através da 
função \textbf{set\_posts}.

A terceira realiza todo o parse relacionado com as \textbf{tags}, 
como por exemplo o \textbf{id\_tag} ou o \textbf{tag\_name}. 
De seguida são colocados na estrutura todos estes elementos através da 
função \textbf{set\_tag}.

Referir que incluimos um ficheiro \textit{debug.h} em todas as queries 
de modo a que seja possível, ou não, imprimir as respostas no 
standard output.

\subsection{Query 1}

Dado o identificador de um post, a função retorna o título do post 
e o nome de utilizador do autor. Se o post for uma resposta, a função
retorna o título e o id do utilizador da pergunta correspondente.

Nesta questão, criamos um  \textbf{Map} onde colocamos todos os posts da comunidade.
Se o ID que recebemos como parâmetro pertencer ao  \textbf{Map} podemos prosseguir com a realização da query.

Criamos um novo map com todos os utilizadores da comunidade. Caso o post seja uma pergunta, retornamos o par com o título do post e o nome do user.

Caso contrário, retornamos o par com o título e o ID da pergunta ( \textbf{parent_id}).

\subsection{Query 2}

Pretendemos obter o top N utilizadores com maior número de posts de 
sempre. Para isto, são considerados tanto perguntas quanto respostas 
dadas pelo respectivo utilizador.

Nesta questão, criamos um \textbf{TreeSet} de clones de 
\textbf{Utilizador}(es), com a intenção de os ordenar decrescentemente 
tendo em conta o \textbf{número de posts} realizados por cada um. 
Tal é realizado pelo \textbf{ComparatorPosts} que implementa a classe
Utilizador.

Seguidamente, através dum \textbf{Iterator}, todos os objetos recebem
o módulo \textbf{get\_key\_id} para retornar os \textbf{N Id's} passados
como parâmetro na query.

\subsection{Query 3}

Dado um intervalo de tempo arbitrário, obtemos o número total de posts 
(identificando perguntas e respostas separadamente) neste período.

Nesta questão, inicializamos \textbf{2 variáveis que vão contar o número de 
perguntas e o número de respostas} que estão dentro da data recebida.
Assim, percorremos todos os posts e verificamos se é pergunta ou resposta,
incrementando a respetiva variável.

Por fim, basta colocar na estrutura \textbf{Pair}, as respetivas variáveis.

\subsection{Query 4}

Dado um intervalo de tempo arbitrário, retornamos todas as perguntas 
contendo uma determinada tag. O retorno da função é uma lista com os IDs 
das perguntas ordenadas em cronologia inversa.

Nesta questão, criamos um \textbf{TreeSet} que implementa o \textbf{Comparator} 
de Datas com a intenção de retornar uma lista de ID's ordenada cronologicamente.

Ou seja, através de um ciclo for, percorremos todos os posts da comunidade e, para
cada um, após verificar que é um \textbf{Post} do tipo pergunta, verificamos também
se este se encontra dentro das datas recebidas. Caso verifique ambas as condições é
criada uma \textbf{lista de strings} na qual são colocadas as \textbf{tags} do
respetivo post.

Finalizando, verificamos se essa lista de tags contém a tag que queremos verificar 
se existe na pergunta e caso se confirme, o post é clonado e adicionado ao TreeSet.
Como queremos retornar os ID's das perguntas criamos uma lista de Long's e um 
Iterator que percorre o TreeSet e coloca os ID's na lista a ser retornada como
resultado.

\subsection{Query 5}

Dado um ID de utilizador, devolvemos a informação do seu perfil (short 
bio) e os IDs dos seus 10 últimos posts (perguntas ou respostas), 
ordenados por cronologia inversa.

Nesta questão, criamos um \textbf{TreeSet} que implementa o \textbf{ComparadorData}
que permite inserir os \textbf{Posts} no Set ordenados cronologicamente.

Assim, o primeiro passo é percorrer todos os posts da comunidade e colocar no TreeSet
todos os posts cujo \textbf{owner\_user\_id} seja o do utilizador que recebemos.

Depois, criamos um \textbf{ArrayList} e um \textbf{Iterator} que vai percorrer o
TreeSet e adicionar os ID's à lista até um total de 10 ID's de utilizadores. 
Por fim, retornamos o Pair com a bio do utilizador e a lista dos ID's dos seus
últimos 10 posts.

\subsection{Query 6}

Dado um intervalo de tempo arbitrário, devolver os IDs das N respostas 
com mais votos, em ordem decrescente do número de votos.

De referir que tivemos em conta o score das perguntas, ao invês da
diferença de votos.

Nesta questão, recorremos mais uma vez à implementação de um Comparator, neste caso,
o \textbf{ComparatorScore} que vai permitir, na função, colocar no \textbf{TreeSet}
os posts em ordem decrescente.

Então, depois de criar o TreeSet que implementa este Comparator, percorremos todos 
os posts da comunidade e, depois de verificar se é um post do tipo resposta e se 
está entre as datas recebidas como parâmetros, colocamos no TreeSet.

Por fim, utilizando o mesmo método de queries anteriores, criamos uma lista que vai
conter os ID's e um iterator para percorrer o Set com os posts. 

Retornamos assim, uma lista com os IDs das N respostas com mais votos.

\subsection{Query 7}

Dado um intervalo de tempo arbitrário, devolver os IDs das N perguntas 
com mais respostas, em ordem decrescente do número de votos.

De referir que as respostas tidas em conta abordam o tempo total, e
não o intervalo de tempo passado como parâmetro.

Nesta questão, implementamos o \textbf{ComparatorAnswer}, para permitir a 
organização decrescente das perguntas tendo em conta o número de respostas.

Depois de criarmos o TreeSet que implementa este Comparator, percorremos todos os
posts, verificando se é uma pergunta e se está dentro das datas dos parâmetros e,
caso se verifique, a pergunta é adicionada ao TreeSet.

Pelo mesmo método de queries anteriores, criamos um  ArrayList de Longs que vai
conter os IDs dessas perguntas, que irão ser adicionados através de um while,
implementando um Iterator.

\subsection{Query 8}

Dado uma palavra, devolver uma lista com os IDs de N perguntas
cujos títulos a contenham, ordenados por cronologia inversa.

Nesta questão, criamos um TreeSet que implementa o \textbf{ComparatorData} (já
utilizado anteriormente) que permite a ordenação cronológica dos posts num TreeSet.

Percorremos todos os posts da comunidade e, após verificar que é uma pergunta,
verificamos se o título desse post contém a String recebida nos parâmetros. Caso 
isso se verifique o post é clonado e adicionado ao TreeSet auxiliar.

Depois, através do método já usado em outras queries, com um Iterator, percorremos
esse TreeSet adicionando a uma List de Longs os ID's dos posts.

\subsection{Query 9}

Dados os IDs de dois utilizadores, devolver as últimas N perguntas, em
cronologia inversa, em que participaram dois utilizadores específicos, 
via pergunta ou respostas.

Nesta questão recorremos à criação de um \textbf{Map} com todos os utilizadores. De seguida, verificamos se o ID de ambos os utilizadores pertence a esse Map.
Caso se verifique, colocamos numa lista (para cada utilizador) os IDs dos posts nos quais estes utilizadores interagiram.

Assim, basta depois percorrer a primeira lista e comparar com os IDs das segunda lista através do método \textbf{contains()} e adicionar a um \textbf{TreeSet} que implementa o \textbf{ComparatorData} para os posts estarem por ordem cronológica.

Por fim, como em queries anteriores e porque queremos apenas os IDs dos posts, criamos um Iterator para percorrer o TreeSet e adicionar a uma List de \textbf{Longs}.



\subsection{Query 10}


Dado o ID de uma pergunta, obter a melhor resposta, tendo em conta
uma média ponderada.

Nesta questão, utilizamos uma \textbf{Map<Long,Posts>} que contém todos os posts da comunidade.

Primeiro, verificamos se o ID da pergunta que recebemos como parâmetro pertence ao Map com todos os posts e se é uma pergunta (pois queremos analisar as respostas dessa pergunta)

Passando estas verificações, criamos outro Map, desta feita com todos os utilizadores da comunidade. Depois, percorremos todos os posts da comunidade, e sempre que for um \textbf{Post_resposta}, verificamos se o \textbf{parent_id} da resposta é o ID que recebemos como parâmetro. Caso se confirme, calculamos a média através da equação fornecida e se esta for melhor que a melhor média calculada até aquela respsota, esta é substituída e colocamos no \textbf{melhor_id} o ID da resposta.



\subsection{Query 11}


Dado um intervalo arbitrário de tempo, devolver os identificadores das N tags
mais usadas pelos N utilizadores com melhor reputação. Em ordem decrescente 
do número de vezes em que a tag foi usada.

Nesta questão, implementamos 2 Comparator's, um para compara as ocorrências de cada tag (ComparatorOcorrencias) e outro que compara a reputação dos utilizadores (ComparatorReputacao).

O primeiro passo é a criação das estruturas. Criamos um \textbf{Map} que tem todos os utilizadores e um \textbf{TreeSet} de utilizadores que implementa o ComparatorReputacao.

Assim no primeiro ciclo for, adicionamos ao \textbf{TreeSet} os utilizadores para ficarem organizado por reputação.

Depois, criamos um \textbf{Iterator} que vai percorrer o \textbf{TreeSet} dos utilizadores ordenados por reputação e, para utilizador, vai percorrer os seus posts_perguntas, verificando se estes se encontram dentro dos parâmetros das datas. Caso se verifique, percorremos todas as tags desse post e para cada tag verificamos se pertence à estrutura todas_tags (contém todas as tags) e incrementamos uma variável que conta as ocorrências, se essa tag pertencer. Caso contrário, adicionamos à estrutura todas_tags essa nova tag.

Após analisarmos as tags dos posts, criamos um TreeSet de \textbf{TagUnique} que implementa o \textbf{ComparatorOcorrencias} para colocar no TreeSet, de forma ordenada por nº de ocorrências cada uma das tags.

Por fim, e como queremos retornar os identificadores das N tags mais usadas, criamos uma List de Long  e, através de um Iterator, colocamos nessa List, N ID's de tags.

\subsection{Clean}


Função que limpa toda a estrutura da comunidade com o auxílio do \textbf{GarbageCollection}.

\section{Conclusão}
\label{sec:conclusao}

//////////////////// FALTA FAZER ////////////////////

Tendo em conta os objetivos definidos, o grupo acha que os resultados 
principais foram obtidos. Além de aprender a trabalhar com ficheiros 
do tipo \textbf{XML}, aprendemos a trabalhar com a biblioteca \textbf{GLib}.
Aliamos também uma evolução da nossa aprendizagem no tema do 
\textbf{encapsulamento}, da \textbf{modularidade} e 
da \textbf{abstração de dados}.

Outros objetivos alcançados são a resolução total das queries e a eficiência
que se faz notar nestas mesmas, assim como a libertação total de memória 
alocada pelo programa.

De uma forma natural, o grupo sentiu dificuldades durante o projeto, sendo 
uma, por exemplo, a necessidade de alterar a base total do trabalho devido
a termos inicialmente considerado a ordenação dos ficheiros, quando só nos
faltava resolver a query 11.

\section{Bibliografia}

//////////////////// FALTA FAZER ////////////////////

\begin{enumerate} 
	\item Prof. F. Mário Martins, \textit{Programação Modular em C};
	\item Prof. F. Mário Martins, \textit{Tipos Incompletos em C}.
\end{enumerate}

\end{document}